"""Slice a network from a set of nodes.

Allows you to slice a graph from preset nodes so that you can
visualize a subgraph of the original graph.

Usage:
    slice_graph.py -i <input_nodes_file> -e <input_edges_file> [-n <nodes>...]

Options:
   -i <input_nodes_file>     The input nodes file, which is the nodes file
                                generated by graph.py
                                default: nodes.json
    -e <input_edges_file>     The input edges file, which is the edges file
                                generated by graph.py
                                default: edges.json
    -n <nodes>                The list of nodes to use as the starting
                                point for the search.  This is a list of strings
                                that are the canonical titles of the nodes.
                                default: 'garlic' 'basil' 'olive oil'

    -h --help                 Show this screen.

                
Example:
    slice_graph.py -i nodes.json -e edges.json -n garlic -n basil -n 'olive oil'
"""

import json
import sys
from docopt import docopt
import os

def main():
    
    # get the arguments
    args = docopt(__doc__)

    # get the input files
    input_nodes_file = args['-i']
    input_edges_file = args['-e']
    nodes = args['-n']

    # check the input files and nodes
    if not os.path.isfile(input_nodes_file):
        print('The input nodes file does not exist')
        sys.exit(1)
    if not os.path.isfile(input_edges_file):
        print('The input edges file does not exist')
        sys.exit(1)
    if args['-n'] is None:
        print('You must specify at least one node')
        sys.exit(1)

    # create the output files
    output_nodes_file = input_nodes_file.replace('.json', '_sliced.json')
    output_edges_file = input_edges_file.replace('.json', '_sliced.json')
  
    # read the input files
    with open(input_nodes_file, 'r') as f:
        input_nodes = json.load(f)
    with open(input_edges_file, 'r') as f:
        input_edges = json.load(f)

    # find every edge that has a node matching an input node
    sliced_nodes = []
    sliced_edges = []
    for edge in input_edges:
        if edge['from'] in nodes or edge['to'] in nodes:
            sliced_edges.append(edge)
            if edge['from'] not in sliced_nodes:
                sliced_nodes.append(edge['from'])
            if edge['to'] not in sliced_nodes:
                sliced_nodes.append(edge['to'])

    # add the node attributes to the sliced nodes
    for node in input_nodes:
        if node['id'] in sliced_nodes:
            sliced_nodes[sliced_nodes.index(node['id'])] = node

    print('\nFrom nodes: {}\n'.format(nodes))
    print('Sliced nodes: {}'.format(len(sliced_nodes)))
    print('Sliced edges: {}'.format(len(sliced_edges)))
    print('')
    print('As you can see, the number of nodes and edges is still')
    print('quite large.  This is why we need to use the Jaccard')
    print('similarity to reduce the number of nodes.')
    print('')
    print('The next step is to run `similarity.py`')
    print('to reduce the number of nodes.')
    print('')

    # graph the output files
    #print('Graphing the output files')
    #os.system('python <graph.py> -n {} -e {}'.format(<output_nodes_file>, <output_edges_file>))

    # write the output files
    with open(output_nodes_file, 'w') as f:
        json.dump(sliced_nodes, f, indent=2)
    with open(output_edges_file, 'w') as f:
        json.dump(sliced_edges, f, indent=2)


if __name__ == '__main__':
    main()
